{"name":"Cling","tagline":"cling: a Python module for automating network device command line interface interaction","body":"<p align=\"center\">\r\n  <img src=\"misc/logo.png\"/>\r\n</p>\r\n<p align=\"center\">Embrace Automation\r\n</p>\r\n\r\n## Cling\r\n\r\nIn the world of APIs and emerging SDN... CLI screen-scrapping remains the primary method for interacting with heterogeneous network infrastructures. \r\n\r\nCling(CLI next gen) is a Python module for automating network device command line interface interaction.\r\n\r\n## Dependencies\r\n\r\n- [optional] Net-SNMP (with Python bindings)  http://www.net-snmp.org/\r\n\r\n## Installation\r\ngit clone from github and:\r\n\r\n```sudo python setup.py install```\r\n\r\nor via PIP\r\n\r\n```pip install cling```\r\n\r\n## Synopsis\r\n```python\r\nimport cling\r\n\r\ntry:\r\n    ch = cling.Cling(hostname='router1.example.com',\r\n                     personality='ios',\r\n                     username='admin',\r\n                     password='secret')\r\n    ch.login()\r\n    print ch.run_command('show version')\r\n    ch.logout()\r\nexcept cling.Error as e:\r\n    print e\r\n```\r\n- This will:\r\n    - spawn ssh command\r\n    - login to router1.example.com\r\n    - run a set of initialisation commands such as switch off paging(depending on the host's personality)\r\n    * run \"show version\" command and print it's output\r\n    * Logout from the device by running exit commands(personality dependent) and killing the spawned ssh process\r\n    * Error message is printed if an error occurs\r\n\r\n## API\r\n\r\n```python\r\nCling(hostname=None,\r\n      personality='generic',\r\n      username=None,\r\n      password=None,\r\n      pexpect_timeout=10,\r\n      pexpect_read_loop_timeout=0.1,\r\n      snmp_community='public',\r\n      snmp_version=2,\r\n      pexpect_maxread=64000,\r\n      pexpect_searchwindowsize=5,\r\n      error_lookup_buffer=100,\r\n      max_login_attempts=2,\r\n      failed_login_retry_pause=3,\r\n      pub_key_auth=False,\r\n      pub_key_path=None,\r\n      extra_ssh_params='',\r\n      ssh_path='/usr/bin/ssh',\r\n      simulation=False)\r\n```\r\n\r\n- `hostname` hostname or IP address to connect to\r\n- `personality` device's personality we're connecting to, this sets a prompt to expect, initialisation commands to run upon login, such as switching off screen paging and exit commands to run upon logout\r\n    - Personalities supported:\r\n        - `generic`       Generic personality (does not run init or exit commands)\r\n        - `ios`           Cisco IOS\r\n        - `iosxr`         Cisco IOS XR\r\n        - `eos`           Arista switches\r\n        - `ironware`      Brocade routers and switches\r\n        - `junos`         Juniper routers\r\n        - `webos`         Radware Alteon ADX\r\n        - `acos`          A10 Networks ADX\r\n        - `netscaler`     Citrix NetScaler ADX\r\n        - `tmos`          F5 BIG-IP LTM/GTM\r\n        - `panos`         PaloAlto PAN-OS\r\n        - `snmp`          attempt to automatically discover personality using snmp sysDescr, requires Net-SNMP Python bindings to be installed. After a successful detection `Cling.persnonality` is set to the detected personality\r\n\r\n- `username` user name to use for login\r\n- `password` password to use for login\r\n\r\n- `pexpect_timeout` initial value of timeout in seconds, used when waiting for a pattern to be matched, i.e. when waiting for a prompt when logging in or executing a command. Increase if working with a slow connection or if a command takes a long time to output. The behaviour can be changed after a succesful login() by setting child.timeout variable, it can be increased on the fly when executing long-running commands, e.g. traceroute, and set back to the original value as needed.\r\n\r\n- `pexpect_read_loop_timeout` when a command is issued (eg. ch.run_command('show running'), the response from the device (ie, the configuration) is read in chunks. The react_loop_timeout variable determines how often (in seconds) will the response buffer be polled for a new configuration chunk. Setting the value too low, eg. 0.0001 may result in configuration not being fetched - setting it to too high, eg. 5 may result in a pexpect_timeout reached. Default 0.1\r\nIn slow connections and **only** if problems occur, try to set it to something higher than 0.1, eg. 0.5 or 0.7 or even 1 (worst case).\r\n\r\n- `snmp_community` community to use with `snmp` personality\r\n\r\n- `snmp_version` snmp version to use with `snmp` personality\r\n\r\n- `pexpect_maxread` readmax this much bytes at a time\r\n\r\n- `pexpect_searchwindowsize` search for prompt in this many last bytes of the output\r\n\r\n- `error_lookup_buffer` search for errors in this many last bytes of the output (default: 100)\r\n\r\n- `max_login_attempts` login attempts after which the device is considered unreachable (default: 3)\r\n\r\n- `pub_key_auth` set True to use public key authentication for ssh (default: False)\r\n\r\n- `pub_key_path` path to public key, added as `-i <pub_key_path>` to the ssh command\r\n\r\n- `extra_ssh_params` str added after username@hostname in the ssh command line\r\n\r\n- `ssh_path` path to ssh binary\r\n\r\n- `simulation` if set to True, commands are not applied to the device. An info-level logger eases logging (default: False)\r\n\r\n### Methods\r\n\r\n- `login()`\r\n\r\nSpawns ssh or telnet, logins to the host and runs the intialisation commands\r\n\r\n- `run_command(command, force_execute=False)`\r\n\r\nSends a command + \"line separator\" to the child process, waits for cli prompt to be matched and returns output buffer minus the echoed command and the cli prompt\r\nError detection is carried on output buffer over the last `error_lookup_buffer` bytes (characters).\r\n\r\n`force_execute` bypasses the simulation mode if set to true and is a shortcut for:\r\n\r\n```python\r\nch.simulation = False\r\nch.run_command('I command you')\r\nch.simulation = True\r\n```\r\n\r\n- Magic command tags\r\n\r\nThe following \"magic\" command tags are supported:\r\n\r\n- `<sleep X>`: Sleep for X seconds\r\n- `<send>command`: will send command without line separator (eg. without \\n)\r\n- `<force_exec>command`: will execute the command regardless of the simulation state\r\n- `<send_line>command`: will send command with line separator\r\n- `<ignore_err>command`: bypasses error checking on command output\r\n \r\nExample:\r\n```python\r\n# JunOS-based device\r\nch = cling.Cling(...,\r\n                 simulation=True)\r\nch.login()\r\n# Will not run the command\r\nch.run_command('edit private')\r\n# Will run the command\r\nch.run_command('<force_exec>edit private')\r\nch.run_command('set hostname test.example.test')\r\nch.run_command('exit', force_exec=True)\r\nch.logout()\r\n```\r\n\r\n- `send(string)`\r\n\r\nSends string to the host, does not wait for the cli prompt to be matched\r\n\r\n- `send_line(string)`\r\n\r\nSends string  + \"line separator\" to the host, does not wait for the cli prompt to be matched\r\n\r\n- `logout()`\r\n\r\nRuns exit commands (depending on personality selected) and kills the spawned process\r\n\r\n### Reactor - running commands on multiple hosts\r\n\r\nThe reactor allows for execution of commands/configuration files on multiple hosts in parallel using the python multiprocessing module under the hood. The reactor is invoked in this way:\r\n\r\n```python\r\nimport cling\r\nreactor = cling.reactor.Reactor(tasks=hosts,\r\n                                func=<applier_function>,\r\n                                num_workers=2)\r\n```                              \r\n                              \r\n\"hosts\" is a list of hostnames, eg.\r\n```hosts = ['test1.example.com', 'test2.example.com']```\r\n\r\nApplier function should apply configuration via cling. It should have a single param that indicates the device *hostname*. An example use case for the applier function is for parsing config files and apply the configuration to a device. So, in this example the applier should take care of log-in to a device, reading the config from file(s) applying it and exit. The reactor takes care of the rest, ie engaging the applier to multiple devices in a case where one would like to roll a new feature to many network devices.\r\n\r\n`num_workers` is obvious, 1 means process the list of hosts in a serial manner. 2 or more implies parallel.\r\n\r\n\r\n### Error handling\r\n`cling.Error` is raised if an error has occurred, e.g connection has been closed by the remote host or timeout occurred waiting for a pattern to be matched. Under the error_handler directory there are device specific error detectors. Detectors act upon each command response and once certain patterns are matched (eg. \"syntax error\") the cling.Error exception is raised.\r\n\r\n## pexpect_ng\r\n*cling uses a modified version of pexpect 2.4, which is distributed under terms (looks like an MIT license), located in pexpect_ng.py*\r\n\r\npyexpect_ng is a modified version of pexpect 2.4. The main difference is in the way the response for the device is searched against matching prompt. \r\nPexpect parses the device response and tries to match the prompt in expect() in every chunk of received data over the last *pexpect_searchwindowsize* characters. Pexpect_ng parses the whole response and then looks for a prompt over the last *pexpect_searchwindowsize* characters.\r\nThis saves the day in case prompt special chars (eg. #, >) are used in the output.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}